function target_dir=merge_v_files(max_lev,sizes,num_CVs,poly_order,k_sampling,k_grid,final_outdir,final_tempdir,dos_on,cond_on)
% MERGE_V_FILES Convert vacancy files for MLMC hierarchy and convert them
% to vacancy files where all samples on the same super cell size are
% contained in one file (to take advantage of the fact that Stephen's code
% only need to construct the tight binding matrices once for each super
% cell size).
%
% Operates on vacancy files stored in subfolders "Vacancies/Vac_Test_lev_*"
% generated by "set_up_samples.m".
%
% Empty vacancy lists (i.e. unperturbed samples) will be omitted from the
% list of jobs, with the corresponding job numbers skipped and the
% corresponding numbers will be saved to keep the information of which
% samples should be replaced by the unperturbed solution in the
% post-processing.
%
% Information about which "job(s)" belong to which sample (either as one of
% four small samples used for one control variate or as a single sample on
% the larger super cell of a bi-level pair) must be stored to compute the
% MLMC estimator from the output files of Stephen's code.
%
% TO BE UPDATED ONCE STEPHEN'S CODE IS UPDATED TO INCLUDE MORE OF THE
% POST-PROCESSING IN THE COMPILED CODE THAT RUNS ON THE CLUSTERS.

%=== Notes from Stephen: ==================================================    
% Ignore the no_vacancies/unpert_samples trick for now... LEO2D does a 
% running average and currently doesn't have the "nopert" (i.e. no vacancy) 
% logic built into the input/output so we will just compute multiple copies 
% of the "nopert" system if needed. This scenario will only be common on 
% the smallest level, and that level is pretty cheap so I think its OK.
%==========================================================================    

outfiles = cell(max_lev,1);
offsets  = inf*ones(max_lev,5);
%unpert_samples = cell(1,max_lev); % Empty vacancy lists will be removed

% Help variables to control job-by-job processing of lines below.
%vacancy_line    = false;
save_this_job   = false;

for k=1:max_lev
  %unpert_samples_lev_k = [];
  all_lines = '';
  % First read samples from file with "level k" as the larger super cell,
  % i.e. more accurate and more costly approximation
  eval(['fh = fopen(''Vacancies',filesep,'Vac_lev_',int2str(k),...
    filesep,'vacancies.dat'',''rt'');'])
  offsets(k,1) = 0;
  % counter keeps track of how many jobs have already been saved 
  counter = 0; maxlines = 1e4; 
  while counter<maxlines % Avoids infinite loop - adjust maxlines if needed
    
    a_line = fgets(fh); % Reads one line -- now procede to analyze it
    
    if a_line==-1       % Have reached end of file.
      if k<max_lev,
        % All levels except the largest super cell appear both in control 
        % variates and on its own. Since all samples are collected in one 
        % file we must keep information about which are which. This is done 
        % by storing "offsets" in the sample list.
        offsets(k,2) = counter;
      end
      break
    end
    
    % Three types of lines: JOB, vacancy list, and empty separation line
    if length(a_line)>4 && strcmp(a_line(1:5),'JOBID')
      this_job = a_line;
      %no_vacancies = false;    % change to true if vacancy line empty
      save_this_job = false;
      counter = counter+1;
    elseif length(a_line)>8 && strcmp(a_line(1:9),'CLUSTERID')
      this_job = [this_job,a_line];
    elseif length(a_line)>2 && strcmp(a_line(1:3),'VAC')
      this_job = [this_job,a_line];     
      %{
      if a_line(end-1:end) == '-1'
        no_vacancies = true;
        unpert_samples_lev_k = [unpert_samples_lev_k, counter];
      end
      %}
    elseif length(a_line)>2 && strcmp(a_line(1:3),'TAR')
      this_job = [this_job,a_line];
    else % separation line
      this_job = [this_job,a_line];
      save_this_job = true;
      %{
      if ~no_vacancies
        this_job = [this_job,a_line];
        save_this_job = true;
      end
      %}
    end
    % After reading lines, add them to all_lines if non-empty vacancy list
    
    if save_this_job
      all_lines = [all_lines,this_job];
    end
  end
  fclose(fh);
  
  % Then read samples from files with "level k" as the smaller super cell,
  % i.e. less accurate and cheaper approximation. Used in Control variates.
  if k<max_lev
    for l=1:4
      save_this_job   = false;
      
      fh = fopen(['Vacancies',filesep,'Vac_lev_',int2str(k+1),filesep,'vacancies_CV',...
        int2str(l),'.dat'],'rt');
     
      while counter<maxlines

        a_line = fgets(fh);
        
        if a_line==-1
          if l<4,
            offsets(k,l+2) = counter;
          end
          break
        end
        
        % Three types of lines: JOB, vacancy list, and empty separation line
        if length(a_line)>4 && strcmp(a_line(1:5),'JOBID')
          this_job = ['JOBID = ',int2str(counter+1),'\n'];
          counter = counter+1;
          %no_vacancies = false;    % change to true if vacancy line empty
          save_this_job = false;
          % Also save CLUSTERID (equal to the JOBID in the higher level)
          tmp = strsplit(a_line,'=');
          this_job = [this_job,'CLUSTERID =',tmp{2}];
          
        elseif length(a_line)>8 && strcmp(a_line(1:9),'CLUSTERID')
          %
        elseif length(a_line)>2 && strcmp(a_line(1:3),'VAC')
          this_job = [this_job,a_line];          
          %{
          if a_line(end-1:end) == '-1'
            no_vacancies = true;
            unpert_samples_lev_k = [unpert_samples_lev_k, counter];
          end
          %}
        elseif length(a_line)>2 && strcmp(a_line(1:3),'TAR')
          this_job = [this_job,a_line];  
        else % separation line
          %if ~no_vacancies
            this_job = [this_job,a_line];
            save_this_job = true;
          %end
        end
        % After reading lines, add them to all_lines
        
        if save_this_job
          all_lines = [all_lines,this_job];
        end
      end
      fclose(fh);
    end
  end
  outfiles{k} = all_lines;
  %unpert_samples{k} = unpert_samples_lev_k;
end

target_dir = make_folder_merge_vacancies;
target_sub_dir = [target_dir,filesep,'all_levels'];


disp(['Writing merged vacancy list files and additional information to ''',...
  target_sub_dir,''''])
eval(['!mkdir ',target_sub_dir]);
eval(['!mkdir ',[target_dir,filesep,'out']]);
eval(['!mkdir ',[target_dir,filesep,'temp']]);


for k=1:max_lev
  %target_sub_dir = [target_dir,filesep,'Lev_',int2str(k)];
  %target_sub_dir = [target_dir,filesep,'all_levels'];
  
  hstructfile = ['hstruct_l',int2str(k),'.in'];
  final_vacfile = ['vacancies_l',int2str(k),'.dat'];
  
  %eval(['!mkdir ',target_sub_dir]);
  fh = fopen([target_sub_dir,filesep,final_vacfile],'w');
  %fh = fopen([target_sub_dir,filesep,'vacancies.dat'],'w');
  fprintf(fh,outfiles{k});
  fclose(fh);
  
  if k == max_lev
      cv_here = 0;
  else
      cv_here = num_CVs(k+1);
  end
  
  k_power = (max_lev - k);
  k_grid_here = k_grid*2^(k_power);
  
  k_sampling_here = k_sampling;
  
  if k_grid_here == 1
     %k_sampling_here = 0; 
  end
  
  hstruct_str = make_hstruct_in(sizes(k), poly_order, k_sampling_here, k_grid_here, max_lev, k,...
      cv_here, final_vacfile,final_outdir, final_tempdir, dos_on, cond_on);
  fh2 = fopen([target_sub_dir,filesep,hstructfile],'w');
  fprintf(fh2,hstruct_str);
  fclose(fh2);
  
end

save([target_dir,filesep,'offset_matrix'],'offsets')
%save([target_dir,filesep,'unpert_lists'],'unpert_samples')

for k=1:max_lev
  eval(['copyfile Vacancies',filesep,'Vac_lev_',int2str(k),...
    filesep,'RNG_initial_state.mat ',target_dir,filesep,...
    'RNG_initial_state_lev_',int2str(k),'.mat'])
end  
  

